<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Vc: Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Vc"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vc
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Utilities.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utilities</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Additional classes, macros, and functions that help to work more easily with the main vector types. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1CpuId.html">CpuId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is available for x86 / AMD64 systems to read and interpret information about the CPU's capabilities.  <a href="classVc_1_1CpuId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVc_1_1AlignedBase.html">AlignedBase&lt; Alignment &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to ensure a given alignment.  <a href="structVc_1_1AlignedBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Common_1_1InterleavedMemoryWrapper.html">InterleavedMemoryWrapper&lt; S, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a pointer to memory with convenience functions to access it via vectors.  <a href="classVc_1_1Common_1_1InterleavedMemoryWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Common_1_1Memory.html">Memory&lt; V, Size1, Size2, InitPadding &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for fixed-size two-dimensional arrays.  <a href="classVc_1_1Common_1_1Memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Common_1_1Memory_3_01V_00_01Size_00_010u_00_01InitPadding_01_4.html">Memory&lt; V, Size, 0u, InitPadding &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to simplify usage of correctly aligned and padded memory, allowing both vector and scalar access.  <a href="classVc_1_1Common_1_1Memory_3_01V_00_01Size_00_010u_00_01InitPadding_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVc_1_1Common_1_1Memory_3_01V_00_010u_00_010u_00_01true_01_4.html">Memory&lt; V, 0u, 0u, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class that is very similar to Memory&lt;V, Size&gt; but with dynamically allocated memory and thus dynamic size.  <a href="classVc_1_1Common_1_1Memory_3_01V_00_010u_00_010u_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae0b1347db1c228fa9eed28bb263b7ce1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gae0b1347db1c228fa9eed28bb263b7ce1">VectorAlignedBase</a> = AlignedBase&lt; Detail::max(alignof(Vector&lt; float &gt;), alignof(Vector&lt; double &gt;), alignof(Vector&lt; ullong &gt;), alignof(Vector&lt; llong &gt;), alignof(Vector&lt; ulong &gt;), alignof(Vector&lt; long &gt;), alignof(Vector&lt; uint &gt;), alignof(Vector&lt; int &gt;), alignof(Vector&lt; ushort &gt;), alignof(Vector&lt; short &gt;), alignof(Vector&lt; uchar &gt;), alignof(Vector&lt; schar &gt;))&gt;</td></tr>
<tr class="memdesc:gae0b1347db1c228fa9eed28bb263b7ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type to ensure suitable alignment for any Vc::Vector&lt;T&gt; type (using the default VectorAbi).  <a href="group__Utilities.html#gae0b1347db1c228fa9eed28bb263b7ce1">More...</a><br /></td></tr>
<tr class="separator:gae0b1347db1c228fa9eed28bb263b7ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf50674e74fd61521eed0b6efc9fca66"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:gaaf50674e74fd61521eed0b6efc9fca66"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaaf50674e74fd61521eed0b6efc9fca66">VectorAlignedBaseT</a> = AlignedBase&lt; alignof(V)&gt;</td></tr>
<tr class="memdesc:gaaf50674e74fd61521eed0b6efc9fca66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of the above type ensuring suitable alignment only for the specified vector type <code>V</code>.  <a href="group__Utilities.html#gaaf50674e74fd61521eed0b6efc9fca66">More...</a><br /></td></tr>
<tr class="separator:gaaf50674e74fd61521eed0b6efc9fca66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga199bb5c0b1cdad984233700da70c7f72"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga199bb5c0b1cdad984233700da70c7f72">MemoryAlignedBase</a> = AlignedBase&lt; Detail::max(Vector&lt; float &gt;::MemoryAlignment, Vector&lt; double &gt;::MemoryAlignment, Vector&lt; ullong &gt;::MemoryAlignment, Vector&lt; llong &gt;::MemoryAlignment, Vector&lt; ulong &gt;::MemoryAlignment, Vector&lt; long &gt;::MemoryAlignment, Vector&lt; uint &gt;::MemoryAlignment, Vector&lt; int &gt;::MemoryAlignment, Vector&lt; ushort &gt;::MemoryAlignment, Vector&lt; short &gt;::MemoryAlignment, Vector&lt; uchar &gt;::MemoryAlignment, Vector&lt; schar &gt;::MemoryAlignment)&gt;</td></tr>
<tr class="memdesc:ga199bb5c0b1cdad984233700da70c7f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to ensure suitable alignment for arrays of scalar objects for any Vc::Vector&lt;T&gt; type (using the default VectorAbi).  <a href="group__Utilities.html#ga199bb5c0b1cdad984233700da70c7f72">More...</a><br /></td></tr>
<tr class="separator:ga199bb5c0b1cdad984233700da70c7f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99b565288c63cae7e848763fd59f7fe3"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ga99b565288c63cae7e848763fd59f7fe3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga99b565288c63cae7e848763fd59f7fe3">MemoryAlignedBaseT</a> = AlignedBase&lt; V::MemoryAlignment &gt;</td></tr>
<tr class="memdesc:ga99b565288c63cae7e848763fd59f7fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of the above type ensuring suitable alignment only for the specified vector type <code>V</code>.  <a href="group__Utilities.html#ga99b565288c63cae7e848763fd59f7fe3">More...</a><br /></td></tr>
<tr class="separator:ga99b565288c63cae7e848763fd59f7fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaebce8b3227fdcca97fba94556a1b2461"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">MallocAlignment</a> { <a class="el" href="group__Utilities.html#ggaebce8b3227fdcca97fba94556a1b2461aea1085049aede31b7bbb8c5a06815446">AlignOnVector</a>, 
<a class="el" href="group__Utilities.html#ggaebce8b3227fdcca97fba94556a1b2461ae5f918b27baba790e8931d2f1173905f">AlignOnCacheline</a>, 
<a class="el" href="group__Utilities.html#ggaebce8b3227fdcca97fba94556a1b2461ae4cff9800dfef630b91432a0eda00f4b">AlignOnPage</a>
 }<tr class="memdesc:gaebce8b3227fdcca97fba94556a1b2461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that specifies the alignment and padding restrictions to use for memory allocation with <a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access. ">Vc::malloc</a>.  <a href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">More...</a><br /></td></tr>
<tr class="separator:gaebce8b3227fdcca97fba94556a1b2461"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga169eae84f24c38906074ff8edde32fd8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga169eae84f24c38906074ff8edde32fd8">Implementation</a> : std::uint_least32_t { <br />
&#160;&#160;<a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8af8eadb5528c544043ceb2e0bbe1615ac">ScalarImpl</a>, 
<a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a96e70e00d8209faf9f4f5d45d5fb2c91">SSE2Impl</a>, 
<a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a7d172cb38b02af566e6e256bc3c9fc6f">SSE3Impl</a>, 
<a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a4f2b8ddd973d24ac7984678bf4a9bf7a">SSSE3Impl</a>, 
<br />
&#160;&#160;<a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a42c84ad8cf63407232d74ccef344d1b4">SSE41Impl</a>, 
<a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a9ebefe4bccb3fb7ae762b9513f7d1f3e">SSE42Impl</a>, 
<a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a43a1748f49066bcfb077da5844e5ac19">AVXImpl</a>, 
<a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a0ec1beefc339f966fe6bc79f29157417">AVX2Impl</a>, 
<br />
&#160;&#160;<a class="el" href="group__Utilities.html#gga169eae84f24c38906074ff8edde32fd8a19fd24b45f41c9b525248c256328b67c">MICImpl</a>
<br />
 }<tr class="memdesc:ga169eae84f24c38906074ff8edde32fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to identify a certain SIMD instruction set.  <a href="group__Utilities.html#ga169eae84f24c38906074ff8edde32fd8">More...</a><br /></td></tr>
<tr class="separator:ga169eae84f24c38906074ff8edde32fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga4922572a6b9846b8c22af338b9441229"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga4922572a6b9846b8c22af338b9441229">ExtraInstructions</a> : std::uint_least32_t { <br />
&#160;&#160;<a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229acaab28ad7711fd8542454766cef23f2c">Float16cInstructions</a> = 0x01000, 
<a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229a785542afdf7805511a1c0d1679a9d6ea">Fma4Instructions</a> = 0x02000, 
<a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229a439e5c3106f696004e78b4f79e5918b6">XopInstructions</a> = 0x04000, 
<a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229aee6cf7ebb69a99ec4ffbdea63d0d7a76">PopcntInstructions</a> = 0x08000, 
<br />
&#160;&#160;<a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229af7a4407dc74ee8444bffedca74ca942d">Sse4aInstructions</a> = 0x10000, 
<a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229a84146480ab7df66c222fdda2f7a513da">FmaInstructions</a> = 0x20000, 
<a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229ab32e7f3ac1f6c7aac5d6d20ae435f84a">VexInstructions</a> = 0x40000, 
<a class="el" href="group__Utilities.html#gga4922572a6b9846b8c22af338b9441229a28c60a6d86220ee7bbbbbecac4db015f">Bmi2Instructions</a> = 0x80000
<br />
 }<tr class="memdesc:ga4922572a6b9846b8c22af338b9441229"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of available instructions is not easily described by a linear list of instruction sets.  <a href="group__Utilities.html#ga4922572a6b9846b8c22af338b9441229">More...</a><br /></td></tr>
<tr class="separator:ga4922572a6b9846b8c22af338b9441229"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga455ba5c796b6a7ea10b4637b5f91fd21"><td class="memTemplParams" colspan="2">template&lt;typename V , typename Parent , typename Dimension , typename RM &gt; </td></tr>
<tr class="memitem:ga455ba5c796b6a7ea10b4637b5f91fd21"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga455ba5c796b6a7ea10b4637b5f91fd21">operator&lt;&lt;</a> (std::ostream &amp;s, const Vc::MemoryBase&lt; V, Parent, Dimension, RM &gt; &amp;m)</td></tr>
<tr class="memdesc:ga455ba5c796b6a7ea10b4637b5f91fd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of a Memory object into a stream object.  <a href="#ga455ba5c796b6a7ea10b4637b5f91fd21">More...</a><br /></td></tr>
<tr class="separator:ga455ba5c796b6a7ea10b4637b5f91fd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f60d3eac127759ab0725a07a27d564a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga5f60d3eac127759ab0725a07a27d564a">versionString</a> ()</td></tr>
<tr class="separator:ga5f60d3eac127759ab0725a07a27d564a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff0ab27c63416b49278b0d00c5981f4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga0ff0ab27c63416b49278b0d00c5981f4">versionNumber</a> ()</td></tr>
<tr class="separator:ga0ff0ab27c63416b49278b0d00c5981f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46f6dfd0208a6b89575f5bbe6c9c9320"><td class="memTemplParams" colspan="2">template&lt;typename Mask , typename T &gt; </td></tr>
<tr class="memitem:ga46f6dfd0208a6b89575f5bbe6c9c9320"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; Vc::is_simd_mask&lt; Mask &gt;::value, typename assert_for_iif&lt; T &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga46f6dfd0208a6b89575f5bbe6c9c9320">iif</a> (const Mask &amp;condition, const T &amp;trueValue, const T &amp;_falseValue)</td></tr>
<tr class="memdesc:ga46f6dfd0208a6b89575f5bbe6c9c9320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to mimic the ternary operator '?:' (inline-if).  <a href="group__Utilities.html#ga46f6dfd0208a6b89575f5bbe6c9c9320">More...</a><br /></td></tr>
<tr class="separator:ga46f6dfd0208a6b89575f5bbe6c9c9320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62e83b56d82bdc33c674d246f1d02909"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga62e83b56d82bdc33c674d246f1d02909"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga62e83b56d82bdc33c674d246f1d02909">iif</a> (bool condition, const T &amp;trueValue, const T &amp;falseValue)</td></tr>
<tr class="memdesc:ga62e83b56d82bdc33c674d246f1d02909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the above for boolean conditions.  <a href="group__Utilities.html#ga62e83b56d82bdc33c674d246f1d02909">More...</a><br /></td></tr>
<tr class="separator:ga62e83b56d82bdc33c674d246f1d02909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9579a3d550ede4c21c20ee5dcb64512"><td class="memTemplParams" colspan="2">template&lt;typename V , typename  = enable_if&lt;Traits::is_simd_vector&lt;V&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gaf9579a3d550ede4c21c20ee5dcb64512"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; V, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaf9579a3d550ede4c21c20ee5dcb64512">interleave</a> (const V &amp;a, const V &amp;b)</td></tr>
<tr class="memdesc:gaf9579a3d550ede4c21c20ee5dcb64512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaves the entries from <code>a</code> and <code>b</code> into two vectors of the same type.  <a href="group__Utilities.html#gaf9579a3d550ede4c21c20ee5dcb64512">More...</a><br /></td></tr>
<tr class="separator:gaf9579a3d550ede4c21c20ee5dcb64512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dfd6909d54c9ca14cdc6aafd2e32454"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:ga3dfd6909d54c9ca14cdc6aafd2e32454"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga3dfd6909d54c9ca14cdc6aafd2e32454">makeContainer</a> (std::initializer_list&lt; T &gt; list) -&gt; decltype(make_container_helper&lt; Container, T &gt;::help(list))        </td></tr>
<tr class="memdesc:ga3dfd6909d54c9ca14cdc6aafd2e32454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a container of <a class="el" href="namespaceVc.html" title="Vector Classes Namespace. ">Vc</a> vectors from a std::initializer_list of scalar entries.  <a href="group__Utilities.html#ga3dfd6909d54c9ca14cdc6aafd2e32454">More...</a><br /></td></tr>
<tr class="separator:ga3dfd6909d54c9ca14cdc6aafd2e32454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad68314ae283bc298864bf18b3aa8a4"><td class="memTemplParams" colspan="2">template&lt;typename T , Vc::MallocAlignment A&gt; </td></tr>
<tr class="memitem:ga3ad68314ae283bc298864bf18b3aa8a4"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4">malloc</a> (size_t n)</td></tr>
<tr class="memdesc:ga3ad68314ae283bc298864bf18b3aa8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory on the Heap with alignment and padding suitable for vectorized access.  <a href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4">More...</a><br /></td></tr>
<tr class="separator:ga3ad68314ae283bc298864bf18b3aa8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7f695ddd66d27230262733d9727435"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaee7f695ddd66d27230262733d9727435"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaee7f695ddd66d27230262733d9727435">free</a> (T *p)</td></tr>
<tr class="memdesc:gaee7f695ddd66d27230262733d9727435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory that was allocated with <a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access. ">Vc::malloc</a>.  <a href="group__Utilities.html#gaee7f695ddd66d27230262733d9727435">More...</a><br /></td></tr>
<tr class="separator:gaee7f695ddd66d27230262733d9727435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga317df7475aed35c78a01edb20acb15c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga317df7475aed35c78a01edb20acb15c9">prefetchForOneRead</a> (const void *addr)</td></tr>
<tr class="memdesc:ga317df7475aed35c78a01edb20acb15c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structVc_1_1Prefetch.html">Prefetch</a> the cacheline containing <code>addr</code> for a single read access.  <a href="group__Utilities.html#ga317df7475aed35c78a01edb20acb15c9">More...</a><br /></td></tr>
<tr class="separator:ga317df7475aed35c78a01edb20acb15c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26078dd5d6dce8a1322e5f5c93cc29ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga26078dd5d6dce8a1322e5f5c93cc29ee">prefetchForModify</a> (const void *addr)</td></tr>
<tr class="memdesc:ga26078dd5d6dce8a1322e5f5c93cc29ee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structVc_1_1Prefetch.html">Prefetch</a> the cacheline containing <code>addr</code> for modification.  <a href="group__Utilities.html#ga26078dd5d6dce8a1322e5f5c93cc29ee">More...</a><br /></td></tr>
<tr class="separator:ga26078dd5d6dce8a1322e5f5c93cc29ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa73e3a7f64b8f7985a28a8d76afc611a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaa73e3a7f64b8f7985a28a8d76afc611a">prefetchClose</a> (const void *addr)</td></tr>
<tr class="memdesc:gaa73e3a7f64b8f7985a28a8d76afc611a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structVc_1_1Prefetch.html">Prefetch</a> the cacheline containing <code>addr</code> to L1 cache.  <a href="group__Utilities.html#gaa73e3a7f64b8f7985a28a8d76afc611a">More...</a><br /></td></tr>
<tr class="separator:gaa73e3a7f64b8f7985a28a8d76afc611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77ab6bddef535f11852d1d6e786fb3db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga77ab6bddef535f11852d1d6e786fb3db">prefetchMid</a> (const void *addr)</td></tr>
<tr class="memdesc:ga77ab6bddef535f11852d1d6e786fb3db"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structVc_1_1Prefetch.html">Prefetch</a> the cacheline containing <code>addr</code> to L2 cache.  <a href="group__Utilities.html#ga77ab6bddef535f11852d1d6e786fb3db">More...</a><br /></td></tr>
<tr class="separator:ga77ab6bddef535f11852d1d6e786fb3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac70f007961d35e633d360fa38970628b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gac70f007961d35e633d360fa38970628b">prefetchFar</a> (const void *addr)</td></tr>
<tr class="memdesc:gac70f007961d35e633d360fa38970628b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structVc_1_1Prefetch.html">Prefetch</a> the cacheline containing <code>addr</code> to L3 cache.  <a href="group__Utilities.html#gac70f007961d35e633d360fa38970628b">More...</a><br /></td></tr>
<tr class="separator:gac70f007961d35e633d360fa38970628b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa18ac68167ac7614731134de7364a1d5"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gaa18ac68167ac7614731134de7364a1d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr WhereImpl::WhereMask&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaa18ac68167ac7614731134de7364a1d5">where</a> (const M &amp;mask)</td></tr>
<tr class="memdesc:gaa18ac68167ac7614731134de7364a1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional assignment.  <a href="group__Utilities.html#gaa18ac68167ac7614731134de7364a1d5">More...</a><br /></td></tr>
<tr class="separator:gaa18ac68167ac7614731134de7364a1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Micro-Architecture Feature Tests</h2></td></tr>
<tr class="memitem:ga382d9c155a283ee6e0b6db203f563ed0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga382d9c155a283ee6e0b6db203f563ed0">extraInstructionsSupported</a> ()</td></tr>
<tr class="memdesc:ga382d9c155a283ee6e0b6db203f563ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the extra instructions supported by the current CPU.  <a href="group__Utilities.html#ga382d9c155a283ee6e0b6db203f563ed0">More...</a><br /></td></tr>
<tr class="separator:ga382d9c155a283ee6e0b6db203f563ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85daae7f9fd2e0509b317bbaaade7d90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga85daae7f9fd2e0509b317bbaaade7d90">isImplementationSupported</a> (<a class="el" href="group__Utilities.html#ga169eae84f24c38906074ff8edde32fd8">Vc::Implementation</a> impl)</td></tr>
<tr class="memdesc:ga85daae7f9fd2e0509b317bbaaade7d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given implementation is supported by the system the code is executing on.  <a href="group__Utilities.html#ga85daae7f9fd2e0509b317bbaaade7d90">More...</a><br /></td></tr>
<tr class="separator:ga85daae7f9fd2e0509b317bbaaade7d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd9588ab59f9c0316f73c4de8b328a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Utilities.html#ga169eae84f24c38906074ff8edde32fd8">Vc::Implementation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga4bd9588ab59f9c0316f73c4de8b328a4">bestImplementationSupported</a> ()</td></tr>
<tr class="memdesc:ga4bd9588ab59f9c0316f73c4de8b328a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the best supported implementation for the current system.  <a href="group__Utilities.html#ga4bd9588ab59f9c0316f73c4de8b328a4">More...</a><br /></td></tr>
<tr class="separator:ga4bd9588ab59f9c0316f73c4de8b328a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a7f1d58808117b81cac7dcd054895e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaf6a7f1d58808117b81cac7dcd054895e">currentImplementationSupported</a> ()</td></tr>
<tr class="memdesc:gaf6a7f1d58808117b81cac7dcd054895e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests that the CPU and Operating System support the vector unit which was compiled for.  <a href="group__Utilities.html#gaf6a7f1d58808117b81cac7dcd054895e">More...</a><br /></td></tr>
<tr class="separator:gaf6a7f1d58808117b81cac7dcd054895e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SIMD Support Feature Macros</h2></td></tr>
<tr class="memitem:ga73ca1802567ceaad20750d35805ca67b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga73ca1802567ceaad20750d35805ca67b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga73ca1802567ceaad20750d35805ca67b">Vc_IMPL</a></td></tr>
<tr class="memdesc:ga73ca1802567ceaad20750d35805ca67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is set to the value of <a class="el" href="group__Utilities.html#ga169eae84f24c38906074ff8edde32fd8">Vc::Implementation</a> that the current translation unit is compiled with. <br /></td></tr>
<tr class="separator:ga73ca1802567ceaad20750d35805ca67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca9110131eb7c8452872c47228a70581"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaca9110131eb7c8452872c47228a70581"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaca9110131eb7c8452872c47228a70581">Vc_IMPL_XOP</a></td></tr>
<tr class="memdesc:gaca9110131eb7c8452872c47228a70581"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with XOP instruction support. <br /></td></tr>
<tr class="separator:gaca9110131eb7c8452872c47228a70581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf642aea334234c5763fd2f253b3dd903"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf642aea334234c5763fd2f253b3dd903"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaf642aea334234c5763fd2f253b3dd903">Vc_IMPL_FMA4</a></td></tr>
<tr class="memdesc:gaf642aea334234c5763fd2f253b3dd903"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with FMA4 instruction support. <br /></td></tr>
<tr class="separator:gaf642aea334234c5763fd2f253b3dd903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11523a3d5d06a1a99aa5297e4695b77d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga11523a3d5d06a1a99aa5297e4695b77d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga11523a3d5d06a1a99aa5297e4695b77d">Vc_IMPL_F16C</a></td></tr>
<tr class="memdesc:ga11523a3d5d06a1a99aa5297e4695b77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with F16C instruction support. <br /></td></tr>
<tr class="separator:ga11523a3d5d06a1a99aa5297e4695b77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8fa0145e882e2ed457c100419cb7fb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8fa0145e882e2ed457c100419cb7fb7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gad8fa0145e882e2ed457c100419cb7fb7">Vc_IMPL_POPCNT</a></td></tr>
<tr class="memdesc:gad8fa0145e882e2ed457c100419cb7fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with POPCNT instruction support. <br /></td></tr>
<tr class="separator:gad8fa0145e882e2ed457c100419cb7fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd058ea9feaf864c49f5d5b3e47d5ce4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacd058ea9feaf864c49f5d5b3e47d5ce4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gacd058ea9feaf864c49f5d5b3e47d5ce4">Vc_IMPL_SSE4a</a></td></tr>
<tr class="memdesc:gacd058ea9feaf864c49f5d5b3e47d5ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with SSE4a instruction support. <br /></td></tr>
<tr class="separator:gacd058ea9feaf864c49f5d5b3e47d5ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga897ebfea14aef60ca586a920d7f51c99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga897ebfea14aef60ca586a920d7f51c99"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga897ebfea14aef60ca586a920d7f51c99">Vc_IMPL_Scalar</a></td></tr>
<tr class="memdesc:ga897ebfea14aef60ca586a920d7f51c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled without any SIMD support. <br /></td></tr>
<tr class="separator:ga897ebfea14aef60ca586a920d7f51c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a117c86a473a415d50a909733cf41b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac0a117c86a473a415d50a909733cf41b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gac0a117c86a473a415d50a909733cf41b">Vc_IMPL_SSE</a></td></tr>
<tr class="memdesc:gac0a117c86a473a415d50a909733cf41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with any version of SSE (but not AVX). <br /></td></tr>
<tr class="separator:gac0a117c86a473a415d50a909733cf41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac720835aa15389b97c5ecdd894699082"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac720835aa15389b97c5ecdd894699082"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gac720835aa15389b97c5ecdd894699082">Vc_IMPL_SSE2</a></td></tr>
<tr class="memdesc:gac720835aa15389b97c5ecdd894699082"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with SSE2 instruction support (excluding SSE3 and up). <br /></td></tr>
<tr class="separator:gac720835aa15389b97c5ecdd894699082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27152a7cb9faab8b231652f6587dc683"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27152a7cb9faab8b231652f6587dc683"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga27152a7cb9faab8b231652f6587dc683">Vc_IMPL_SSE3</a></td></tr>
<tr class="memdesc:ga27152a7cb9faab8b231652f6587dc683"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with SSE3 instruction support (excluding SSSE3 and up). <br /></td></tr>
<tr class="separator:ga27152a7cb9faab8b231652f6587dc683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad355a0df26c1318673b063f625c5713a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad355a0df26c1318673b063f625c5713a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gad355a0df26c1318673b063f625c5713a">Vc_IMPL_SSSE3</a></td></tr>
<tr class="memdesc:gad355a0df26c1318673b063f625c5713a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with SSSE3 instruction support (excluding SSE4.1 and up). <br /></td></tr>
<tr class="separator:gad355a0df26c1318673b063f625c5713a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43716dcf60655f02e1d61608ce6e24ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga43716dcf60655f02e1d61608ce6e24ae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga43716dcf60655f02e1d61608ce6e24ae">Vc_IMPL_SSE4_1</a></td></tr>
<tr class="memdesc:ga43716dcf60655f02e1d61608ce6e24ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with SSE4.1 instruction support (excluding SSE4.2 and up). <br /></td></tr>
<tr class="separator:ga43716dcf60655f02e1d61608ce6e24ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01be2b242fa9a71585d019812d0f41ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga01be2b242fa9a71585d019812d0f41ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga01be2b242fa9a71585d019812d0f41ef">Vc_IMPL_SSE4_2</a></td></tr>
<tr class="memdesc:ga01be2b242fa9a71585d019812d0f41ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with SSE4.2 instruction support (excluding AVX and up). <br /></td></tr>
<tr class="separator:ga01be2b242fa9a71585d019812d0f41ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad076abbc55b7127e2357ee135223f80b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad076abbc55b7127e2357ee135223f80b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gad076abbc55b7127e2357ee135223f80b">Vc_IMPL_AVX</a></td></tr>
<tr class="memdesc:gad076abbc55b7127e2357ee135223f80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro is defined if the current translation unit is compiled with AVX instruction support (excluding AVX2 and up). <br /></td></tr>
<tr class="separator:gad076abbc55b7127e2357ee135223f80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Version Macros</h2></td></tr>
<tr class="memitem:gae218d8d8293a6ad61679d8e840b34987"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gae218d8d8293a6ad61679d8e840b34987">Vc_VERSION_STRING</a></td></tr>
<tr class="memdesc:gae218d8d8293a6ad61679d8e840b34987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the version string of the Vc headers.  <a href="#gae218d8d8293a6ad61679d8e840b34987">More...</a><br /></td></tr>
<tr class="separator:gae218d8d8293a6ad61679d8e840b34987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacef58e3522b9da044f9c9210afe04d64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gacef58e3522b9da044f9c9210afe04d64">Vc_VERSION_NUMBER</a></td></tr>
<tr class="memdesc:gacef58e3522b9da044f9c9210afe04d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the encoded version number of the Vc headers.  <a href="#gacef58e3522b9da044f9c9210afe04d64">More...</a><br /></td></tr>
<tr class="separator:gacef58e3522b9da044f9c9210afe04d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb3b9dfb546751c9185e28df58ab691"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga5bb3b9dfb546751c9185e28df58ab691">Vc_VERSION_CHECK</a>(major,  minor,  patch)</td></tr>
<tr class="memdesc:ga5bb3b9dfb546751c9185e28df58ab691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro to compare against an encoded version number.  <a href="#ga5bb3b9dfb546751c9185e28df58ab691">More...</a><br /></td></tr>
<tr class="separator:ga5bb3b9dfb546751c9185e28df58ab691"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SIMD Vector Size Macros</h2></td></tr>
<tr class="memitem:ga2c7ca1b54abb26d4f6a2cf9133c75551"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c7ca1b54abb26d4f6a2cf9133c75551"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga2c7ca1b54abb26d4f6a2cf9133c75551">Vc_DOUBLE_V_SIZE</a></td></tr>
<tr class="memdesc:ga2c7ca1b54abb26d4f6a2cf9133c75551"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a double_v. <br /></td></tr>
<tr class="separator:ga2c7ca1b54abb26d4f6a2cf9133c75551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5008eba7e24c753a4b6031b8ae222e18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5008eba7e24c753a4b6031b8ae222e18"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga5008eba7e24c753a4b6031b8ae222e18">Vc_FLOAT_V_SIZE</a></td></tr>
<tr class="memdesc:ga5008eba7e24c753a4b6031b8ae222e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a float_v. <br /></td></tr>
<tr class="separator:ga5008eba7e24c753a4b6031b8ae222e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d4df1a25e6651e6f1e63f268df56d60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5d4df1a25e6651e6f1e63f268df56d60"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga5d4df1a25e6651e6f1e63f268df56d60">Vc_INT_V_SIZE</a></td></tr>
<tr class="memdesc:ga5d4df1a25e6651e6f1e63f268df56d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a int_v. <br /></td></tr>
<tr class="separator:ga5d4df1a25e6651e6f1e63f268df56d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab44859bbfb5ef7a2fb2b3c5bb1a47100"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab44859bbfb5ef7a2fb2b3c5bb1a47100"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gab44859bbfb5ef7a2fb2b3c5bb1a47100">Vc_UINT_V_SIZE</a></td></tr>
<tr class="memdesc:gab44859bbfb5ef7a2fb2b3c5bb1a47100"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a uint_v. <br /></td></tr>
<tr class="separator:gab44859bbfb5ef7a2fb2b3c5bb1a47100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19584abbfcd0d40b60921bf5d267c4de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga19584abbfcd0d40b60921bf5d267c4de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga19584abbfcd0d40b60921bf5d267c4de">Vc_SHORT_V_SIZE</a></td></tr>
<tr class="memdesc:ga19584abbfcd0d40b60921bf5d267c4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a short_v. <br /></td></tr>
<tr class="separator:ga19584abbfcd0d40b60921bf5d267c4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga816007ce922c3d0c54d975b4fb7c4dc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga816007ce922c3d0c54d975b4fb7c4dc2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga816007ce922c3d0c54d975b4fb7c4dc2">Vc_USHORT_V_SIZE</a></td></tr>
<tr class="memdesc:ga816007ce922c3d0c54d975b4fb7c4dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer (for use with the preprocessor) that gives the number of entries in a ushort_v. <br /></td></tr>
<tr class="separator:ga816007ce922c3d0c54d975b4fb7c4dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Boolean Reductions</h2></td></tr>
<tr class="memitem:gaccfe8b53188a645a5c78e283defb0d23"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaccfe8b53188a645a5c78e283defb0d23"></a>
template&lt;typename Mask &gt; </td></tr>
<tr class="memitem:gaccfe8b53188a645a5c78e283defb0d23"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gaccfe8b53188a645a5c78e283defb0d23">all_of</a> (const Mask &amp;m)</td></tr>
<tr class="memdesc:gaccfe8b53188a645a5c78e283defb0d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all entries in the mask <code>m</code> are <code>true</code>. <br /></td></tr>
<tr class="separator:gaccfe8b53188a645a5c78e283defb0d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec7a6f4bff7ae67660a62ab0f3d325e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6ec7a6f4bff7ae67660a62ab0f3d325e"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga6ec7a6f4bff7ae67660a62ab0f3d325e">all_of</a> (bool b)</td></tr>
<tr class="memdesc:ga6ec7a6f4bff7ae67660a62ab0f3d325e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>b</code>. <br /></td></tr>
<tr class="separator:ga6ec7a6f4bff7ae67660a62ab0f3d325e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e357178e07b595d2e7879ca2b2c62e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0e357178e07b595d2e7879ca2b2c62e0"></a>
template&lt;typename Mask &gt; </td></tr>
<tr class="memitem:ga0e357178e07b595d2e7879ca2b2c62e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga0e357178e07b595d2e7879ca2b2c62e0">any_of</a> (const Mask &amp;m)</td></tr>
<tr class="memdesc:ga0e357178e07b595d2e7879ca2b2c62e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether at least one entry in the mask <code>m</code> is <code>true</code>. <br /></td></tr>
<tr class="separator:ga0e357178e07b595d2e7879ca2b2c62e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae493dec4ade732c6dbcc8232984736c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae493dec4ade732c6dbcc8232984736c5"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gae493dec4ade732c6dbcc8232984736c5">any_of</a> (bool b)</td></tr>
<tr class="memdesc:gae493dec4ade732c6dbcc8232984736c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>b</code>. <br /></td></tr>
<tr class="separator:gae493dec4ade732c6dbcc8232984736c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe433dbbaa1f39731be6d183269cee3d"><td class="memTemplParams" colspan="2"><a class="anchor" id="gabe433dbbaa1f39731be6d183269cee3d"></a>
template&lt;typename Mask &gt; </td></tr>
<tr class="memitem:gabe433dbbaa1f39731be6d183269cee3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gabe433dbbaa1f39731be6d183269cee3d">none_of</a> (const Mask &amp;m)</td></tr>
<tr class="memdesc:gabe433dbbaa1f39731be6d183269cee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether all entries in the mask <code>m</code> are <code>false</code>. <br /></td></tr>
<tr class="separator:gabe433dbbaa1f39731be6d183269cee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac158e87aaeb3b48d2eed8e2b2ed2a616"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac158e87aaeb3b48d2eed8e2b2ed2a616"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gac158e87aaeb3b48d2eed8e2b2ed2a616">none_of</a> (bool b)</td></tr>
<tr class="memdesc:gac158e87aaeb3b48d2eed8e2b2ed2a616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>!b</code>. <br /></td></tr>
<tr class="separator:gac158e87aaeb3b48d2eed8e2b2ed2a616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1f3affaf171f27a677d71501feb7ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0d1f3affaf171f27a677d71501feb7ca"></a>
template&lt;typename Mask &gt; </td></tr>
<tr class="memitem:ga0d1f3affaf171f27a677d71501feb7ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Utilities.html#ga0d1f3affaf171f27a677d71501feb7ca">some_of</a> (const Mask &amp;m)</td></tr>
<tr class="memdesc:ga0d1f3affaf171f27a677d71501feb7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether at least one entry in <code>m</code> is <code>true</code> and at least one entry in <code>m</code> is <code>false</code>. <br /></td></tr>
<tr class="separator:ga0d1f3affaf171f27a677d71501feb7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc58eaa9b950fbdd74931ffe2d28f27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafbc58eaa9b950fbdd74931ffe2d28f27"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Utilities.html#gafbc58eaa9b950fbdd74931ffe2d28f27">some_of</a> (bool)</td></tr>
<tr class="memdesc:gafbc58eaa9b950fbdd74931ffe2d28f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>false</code>. <br /></td></tr>
<tr class="separator:gafbc58eaa9b950fbdd74931ffe2d28f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de46be5a9ab264334dbb33e877c8980"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4de46be5a9ab264334dbb33e877c8980"></a>
template&lt;typename InputIt , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:ga4de46be5a9ab264334dbb33e877c8980"><td class="memTemplItemLeft" align="right" valign="top">enable_if&lt; std::is_arithmetic&lt; typename InputIt::value_type &gt;::value &amp;&amp;Traits::is_functor_argument_immutable&lt; UnaryFunction, Vector&lt; typename InputIt::value_type &gt; &gt;::value, UnaryFunction &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>simd_for_each</b> (InputIt first, InputIt last, UnaryFunction f)</td></tr>
<tr class="separator:ga4de46be5a9ab264334dbb33e877c8980"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gae218d8d8293a6ad61679d8e840b34987"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Vc_VERSION_STRING</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains the version string of the Vc headers. </p>
<p>Same as <a class="el" href="group__Utilities.html#ga5f60d3eac127759ab0725a07a27d564a">Vc::versionString()</a>. </p>

</div>
</div>
<a class="anchor" id="gacef58e3522b9da044f9c9210afe04d64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Vc_VERSION_NUMBER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains the encoded version number of the Vc headers. </p>
<p>Same as <a class="el" href="group__Utilities.html#ga0ff0ab27c63416b49278b0d00c5981f4">Vc::versionNumber()</a>. </p>

</div>
</div>
<a class="anchor" id="ga5bb3b9dfb546751c9185e28df58ab691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Vc_VERSION_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">major, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">minor, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">patch&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro to compare against an encoded version number. </p>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#if Vc_VERSION_CHECK(0.5.1) &gt;= Vc_VERSION_NUMBER</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gae0b1347db1c228fa9eed28bb263b7ce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using VectorAlignedBase =  AlignedBase&lt; Detail::max(alignof(Vector&lt;float&gt;), alignof(Vector&lt;double&gt;), alignof(Vector&lt;ullong&gt;), alignof(Vector&lt;llong&gt;), alignof(Vector&lt;ulong&gt;), alignof(Vector&lt;long&gt;), alignof(Vector&lt;uint&gt;), alignof(Vector&lt;int&gt;), alignof(Vector&lt;ushort&gt;), alignof(Vector&lt;short&gt;), alignof(Vector&lt;uchar&gt;), alignof(Vector&lt;schar&gt;))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type to ensure suitable alignment for any Vc::Vector&lt;T&gt; type (using the default VectorAbi). </p>
<p>This class reimplements the <code>new</code> and <code>delete</code> operators to align objects allocated on the heap suitably for objects of Vc::Vector&lt;T&gt; type. This is necessary since the standard <code>new</code> operator does not adhere to the alignment requirements of the type.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#gaaf50674e74fd61521eed0b6efc9fca66" title="Variant of the above type ensuring suitable alignment only for the specified vector type V...">Vc::VectorAlignedBaseT</a> </dd>
<dd>
<a class="el" href="group__Utilities.html#ga199bb5c0b1cdad984233700da70c7f72" title="Helper class to ensure suitable alignment for arrays of scalar objects for any Vc::Vector<T> type (us...">Vc::MemoryAlignedBase</a> </dd>
<dd>
<a class="el" href="structVc_1_1AlignedBase.html" title="Helper class to ensure a given alignment. ">Vc::AlignedBase</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf50674e74fd61521eed0b6efc9fca66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using VectorAlignedBaseT =  AlignedBase&lt;alignof(V)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of the above type ensuring suitable alignment only for the specified vector type <code>V</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#gae0b1347db1c228fa9eed28bb263b7ce1" title="Helper type to ensure suitable alignment for any Vc::Vector<T> type (using the default VectorAbi)...">Vc::VectorAlignedBase</a> </dd>
<dd>
<a class="el" href="group__Utilities.html#ga99b565288c63cae7e848763fd59f7fe3" title="Variant of the above type ensuring suitable alignment only for the specified vector type V...">Vc::MemoryAlignedBaseT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga199bb5c0b1cdad984233700da70c7f72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using MemoryAlignedBase =  AlignedBase&lt; Detail::max(Vector&lt;float&gt;::MemoryAlignment, Vector&lt;double&gt;::MemoryAlignment, Vector&lt;ullong&gt;::MemoryAlignment, Vector&lt;llong&gt;::MemoryAlignment, Vector&lt;ulong&gt;::MemoryAlignment, Vector&lt;long&gt;::MemoryAlignment, Vector&lt;uint&gt;::MemoryAlignment, Vector&lt;int&gt;::MemoryAlignment, Vector&lt;ushort&gt;::MemoryAlignment, Vector&lt;short&gt;::MemoryAlignment, Vector&lt;uchar&gt;::MemoryAlignment, Vector&lt;schar&gt;::MemoryAlignment)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper class to ensure suitable alignment for arrays of scalar objects for any Vc::Vector&lt;T&gt; type (using the default VectorAbi). </p>
<p>This class reimplements the <code>new</code> and <code>delete</code> operators to align objects allocated on the heap suitably for arrays of type <code><a class="el" href="classVc_1_1Vector.html#a3bf7fb44f113fe902e383e77e89229de" title="The type of the entries in the vector. ">Vc::Vector&lt;T&gt;::EntryType</a></code>. Subsequent load and store operations are safe to use the aligned variant.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga99b565288c63cae7e848763fd59f7fe3" title="Variant of the above type ensuring suitable alignment only for the specified vector type V...">Vc::MemoryAlignedBaseT</a> </dd>
<dd>
<a class="el" href="group__Utilities.html#gae0b1347db1c228fa9eed28bb263b7ce1" title="Helper type to ensure suitable alignment for any Vc::Vector<T> type (using the default VectorAbi)...">Vc::VectorAlignedBase</a> </dd>
<dd>
<a class="el" href="structVc_1_1AlignedBase.html" title="Helper class to ensure a given alignment. ">Vc::AlignedBase</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga99b565288c63cae7e848763fd59f7fe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using MemoryAlignedBaseT =  AlignedBase&lt;V::MemoryAlignment&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of the above type ensuring suitable alignment only for the specified vector type <code>V</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga199bb5c0b1cdad984233700da70c7f72" title="Helper class to ensure suitable alignment for arrays of scalar objects for any Vc::Vector<T> type (us...">Vc::MemoryAlignedBase</a> </dd>
<dd>
<a class="el" href="group__Utilities.html#gaaf50674e74fd61521eed0b6efc9fca66" title="Variant of the above type ensuring suitable alignment only for the specified vector type V...">Vc::VectorAlignedBaseT</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaebce8b3227fdcca97fba94556a1b2461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">MallocAlignment</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum that specifies the alignment and padding restrictions to use for memory allocation with <a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access. ">Vc::malloc</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaebce8b3227fdcca97fba94556a1b2461aea1085049aede31b7bbb8c5a06815446"></a>AlignOnVector&#160;</td><td class="fielddoc">
<p>Align on boundary of vector sizes (e.g. </p>
<p>16 Bytes on SSE platforms) and pad to allow vector access to the end. Thus the allocated memory contains a multiple of VectorAlignment bytes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaebce8b3227fdcca97fba94556a1b2461ae5f918b27baba790e8931d2f1173905f"></a>AlignOnCacheline&#160;</td><td class="fielddoc">
<p>Align on boundary of cache line sizes (e.g. </p>
<p>64 Bytes on x86) and pad to allow full cache line access to the end. Thus the allocated memory contains a multiple of 64 bytes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaebce8b3227fdcca97fba94556a1b2461ae4cff9800dfef630b91432a0eda00f4b"></a>AlignOnPage&#160;</td><td class="fielddoc">
<p>Align on boundary of page sizes (e.g. </p>
<p>4096 Bytes on x86) and pad to allow full page access to the end. Thus the allocated memory contains a multiple of 4096 bytes. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga169eae84f24c38906074ff8edde32fd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Utilities.html#ga169eae84f24c38906074ff8edde32fd8">Implementation</a> : std::uint_least32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to identify a certain SIMD instruction set. </p>
<p>You can use <a class="el" href="group__Utilities.html#ga73ca1802567ceaad20750d35805ca67b">Vc_IMPL</a> for the currently active implementation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga4922572a6b9846b8c22af338b9441229" title="The list of available instructions is not easily described by a linear list of instruction sets...">ExtraInstructions</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga169eae84f24c38906074ff8edde32fd8af8eadb5528c544043ceb2e0bbe1615ac"></a>ScalarImpl&#160;</td><td class="fielddoc">
<p>uses only fundamental types </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga169eae84f24c38906074ff8edde32fd8a96e70e00d8209faf9f4f5d45d5fb2c91"></a>SSE2Impl&#160;</td><td class="fielddoc">
<p>x86 SSE + SSE2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga169eae84f24c38906074ff8edde32fd8a7d172cb38b02af566e6e256bc3c9fc6f"></a>SSE3Impl&#160;</td><td class="fielddoc">
<p>x86 SSE + SSE2 + SSE3 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga169eae84f24c38906074ff8edde32fd8a4f2b8ddd973d24ac7984678bf4a9bf7a"></a>SSSE3Impl&#160;</td><td class="fielddoc">
<p>x86 SSE + SSE2 + SSE3 + SSSE3 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga169eae84f24c38906074ff8edde32fd8a42c84ad8cf63407232d74ccef344d1b4"></a>SSE41Impl&#160;</td><td class="fielddoc">
<p>x86 SSE + SSE2 + SSE3 + SSSE3 + SSE4.1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga169eae84f24c38906074ff8edde32fd8a9ebefe4bccb3fb7ae762b9513f7d1f3e"></a>SSE42Impl&#160;</td><td class="fielddoc">
<p>x86 SSE + SSE2 + SSE3 + SSSE3 + SSE4.1 + SSE4.2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga169eae84f24c38906074ff8edde32fd8a43a1748f49066bcfb077da5844e5ac19"></a>AVXImpl&#160;</td><td class="fielddoc">
<p>x86 AVX </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga169eae84f24c38906074ff8edde32fd8a0ec1beefc339f966fe6bc79f29157417"></a>AVX2Impl&#160;</td><td class="fielddoc">
<p>x86 AVX + AVX2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga169eae84f24c38906074ff8edde32fd8a19fd24b45f41c9b525248c256328b67c"></a>MICImpl&#160;</td><td class="fielddoc">
<p>Intel Xeon Phi. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4922572a6b9846b8c22af338b9441229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Utilities.html#ga4922572a6b9846b8c22af338b9441229">ExtraInstructions</a> : std::uint_least32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The list of available instructions is not easily described by a linear list of instruction sets. </p>
<p>On x86 the following instruction sets always include their predecessors: SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2</p>
<p>But there are additional instructions that are not necessarily required by this list. These are covered in this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4922572a6b9846b8c22af338b9441229acaab28ad7711fd8542454766cef23f2c"></a>Float16cInstructions&#160;</td><td class="fielddoc">
<p>Support for float16 conversions in hardware. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4922572a6b9846b8c22af338b9441229a785542afdf7805511a1c0d1679a9d6ea"></a>Fma4Instructions&#160;</td><td class="fielddoc">
<p>Support for FMA4 instructions. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4922572a6b9846b8c22af338b9441229a439e5c3106f696004e78b4f79e5918b6"></a>XopInstructions&#160;</td><td class="fielddoc">
<p>Support for XOP instructions. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4922572a6b9846b8c22af338b9441229aee6cf7ebb69a99ec4ffbdea63d0d7a76"></a>PopcntInstructions&#160;</td><td class="fielddoc">
<p>Support for the population count instruction. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4922572a6b9846b8c22af338b9441229af7a4407dc74ee8444bffedca74ca942d"></a>Sse4aInstructions&#160;</td><td class="fielddoc">
<p>Support for SSE4a instructions. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4922572a6b9846b8c22af338b9441229a84146480ab7df66c222fdda2f7a513da"></a>FmaInstructions&#160;</td><td class="fielddoc">
<p>Support for FMA instructions (3 operand variant) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4922572a6b9846b8c22af338b9441229ab32e7f3ac1f6c7aac5d6d20ae435f84a"></a>VexInstructions&#160;</td><td class="fielddoc">
<p>Support for ternary instruction coding (VEX) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4922572a6b9846b8c22af338b9441229a28c60a6d86220ee7bbbbbecac4db015f"></a>Bmi2Instructions&#160;</td><td class="fielddoc">
<p>Support for BMI2 instructions. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga382d9c155a283ee6e0b6db203f563ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Vc::extraInstructionsSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the extra instructions supported by the current CPU. </p>
<dl class="section return"><dt>Returns</dt><dd>A combination of flags from Vc::ExtraInstructions that the current CPU supports. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85daae7f9fd2e0509b317bbaaade7d90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Vc::isImplementationSupported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Utilities.html#ga169eae84f24c38906074ff8edde32fd8">Vc::Implementation</a>&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether the given implementation is supported by the system the code is executing on. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the OS and hardware support execution of instructions defined by <code>impl</code>. </dd>
<dd>
<code>false</code> otherwise</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>The SIMD target to test for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4bd9588ab59f9c0316f73c4de8b328a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Utilities.html#ga169eae84f24c38906074ff8edde32fd8">Vc::Implementation</a> Vc::bestImplementationSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the best supported implementation for the current system. </p>
<dl class="section return"><dt>Returns</dt><dd>The enum value for the best implementation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6a7f1d58808117b81cac7dcd054895e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Vc::currentImplementationSupported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests that the CPU and Operating System support the vector unit which was compiled for. </p>
<p>This function should be called before any other <a class="el" href="namespaceVc.html" title="Vector Classes Namespace. ">Vc</a> functionality is used. It checks whether the program will work. If this function returns <code>false</code> then the program should exit with a useful error message before the OS has to kill it because of an invalid instruction exception.</p>
<p>If the program continues and makes use of any vector features not supported by hard- or software then the program will crash.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!<a class="code" href="group__Utilities.html#gaf6a7f1d58808117b81cac7dcd054895e">Vc::currentImplementationSupported</a>()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;CPU or OS requirements not met for the compiled in vector unit!\n&quot;</span>;</div>
<div class="line">    exit -1;</div>
<div class="line">  }</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the OS and hardware support execution of the currently selected SIMD instructions. </dd>
<dd>
<code>false</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga455ba5c796b6a7ea10b4637b5f91fd21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vc::MemoryBase&lt; V, Parent, Dimension, RM &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of a Memory object into a stream object. </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Vc::Memory&lt;int_v, 10&gt; m;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;for (int i = 0; i &lt; m.entriesCount(); ++i) {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  m[i] = i;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;std::cout &lt;&lt; m &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> will output (with SSE): </p><pre class="fragment">{[0, 1, 2, 3] [4, 5, 6, 7] [8, 9, 0, 0]}
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Any standard C++ ostream object. For example std::cout or a std::stringstream object. </td></tr>
    <tr><td class="paramname">m</td><td>Any Vc::Memory object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ostream object: to chain multiple stream operations.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>With the GNU standard library this function will check, whether the output stream is a tty. In that case it will colorize the output.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Please do not forget that printing a large memory object can take a long time. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f60d3eac127759ab0725a07a27d564a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Vc::versionString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the version string of the Vc headers.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There exists a built-in check that ensures on application startup that the Vc version of the library (link time) and the headers (compile time) are equal. A mismatch between headers and library could lead to errors that are very hard to debug. </dd>
<dd>
If you need to disable the check (it costs a very small amount of application startup time) you can define Vc_NO_VERSION_CHECK at compile time. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ff0ab27c63416b49278b0d00c5981f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Vc::versionNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the version of the Vc headers encoded in an integer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46f6dfd0208a6b89575f5bbe6c9c9320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;Vc::is_simd_mask&lt;Mask&gt;::value, typename assert_for_iif&lt;T&gt;::type&gt;::type Vc::iif </td>
          <td>(</td>
          <td class="paramtype">const Mask &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>trueValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>_falseValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to mimic the ternary operator '?:' (inline-if). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>Determines which values are returned. This is analog to the first argument to the ternary operator. </td></tr>
    <tr><td class="paramname">trueValue</td><td>The values to return where <code>condition</code> is <code>true</code>. </td></tr>
    <tr><td class="paramname">falseValue</td><td>The values to return where <code>condition</code> is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A combination of entries from <code>trueValue</code> and <code>falseValue</code>, according to <code>condition</code>.</dd></dl>
<p>So instead of the scalar variant </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> x = a &gt; 1.f ? b : b + c;</div>
</div><!-- fragment --><p> you'd write </p><div class="fragment"><div class="line">float_v x = <a class="code" href="group__Utilities.html#ga46f6dfd0208a6b89575f5bbe6c9c9320">Vc::iif</a> (a &gt; 1.f, b, b + c);</div>
</div><!-- fragment --><p>Assuming <code>a</code> has the values [0, 3, 5, 1], <code>b</code> is [1, 1, 1, 1], and <code>c</code> is [1, 2, 3, 4], then x will be [2, 2, 3, 5]. </p>

</div>
</div>
<a class="anchor" id="ga62e83b56d82bdc33c674d246f1d02909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T Vc::iif </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>trueValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>falseValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the above for boolean conditions. </p>
<p>This typically results in direct use of the ternary operator. This function makes it easier to switch from a <a class="el" href="namespaceVc.html" title="Vector Classes Namespace. ">Vc</a> type to a builtin type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>Determines which value is returned. This is analog to the first argument to the ternary operator. </td></tr>
    <tr><td class="paramname">trueValue</td><td>The value to return if <code>condition</code> is <code>true</code>. </td></tr>
    <tr><td class="paramname">falseValue</td><td>The value to return if <code>condition</code> is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either <code>trueValue</code> or <code>falseValue</code>, depending on <code>condition</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9579a3d550ede4c21c20ee5dcb64512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;V, V&gt; Vc::interleave </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaves the entries from <code>a</code> and <code>b</code> into two vectors of the same type. </p>
<p>The order in the returned vector contains the elements `a[0], b[0], a[1], b[1], a[2], b[2], a[3], b[3], ...`.</p>
<p>Example: </p><div class="fragment"><div class="line">Vc::SimdArray&lt;int, 4&gt; a = { 1, 2, 3, 4 };</div>
<div class="line">Vc::SimdArray&lt;int, 4&gt; b = { 9, 8, 7, 6 };</div>
<div class="line">std::tie(a, b) = <a class="code" href="group__Utilities.html#gaf9579a3d550ede4c21c20ee5dcb64512">Vc::interleave</a>(a, b);</div>
<div class="line">std::cout &lt;&lt; a &lt;&lt; b;</div>
<div class="line"><span class="comment">// prints:</span></div>
<div class="line"><span class="comment">// &lt;1 9 2 8&gt;&lt;3 7 4 6&gt;</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input vector whose data will appear at even indexes in the output </td></tr>
    <tr><td class="paramname">b</td><td>input vector whose data will appear at odd indexes in the output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>two vectors with data from <code>a</code> and <code>b</code> interleaved </dd></dl>

</div>
</div>
<a class="anchor" id="ga3dfd6909d54c9ca14cdc6aafd2e32454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Vc::makeContainer </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> -&gt; decltype(make_container_helper&lt;Container, T&gt;::help(list))
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a container of <a class="el" href="namespaceVc.html" title="Vector Classes Namespace. ">Vc</a> vectors from a std::initializer_list of scalar entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>An initializer list of arbitrary size. The type of the entries is important! If you pass a list of integers you will get a container filled with <a class="el" href="classVc_1_1int__v.html" title="SIMD Vector of 32 bit signed integers. ">Vc::int_v</a> objects. If, instead, you want to have a container of <a class="el" href="classVc_1_1float__v.html" title="SIMD Vector of single precision floats. ">Vc::float_v</a> objects, be sure the include a period (.) and the 'f' postfix in the literals.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a container of the requested class filled with the minimum number of SIMD vectors to hold the values in the initializer list.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> data = Vc::makeContainer&lt;std::vector&lt;float_v&gt;&gt;({ 1.f, 2.f, 3.f, 4.f, 5.f });</div>
<div class="line"><span class="comment">// data.size() == 5 if float_v::Size == 1 (i.e. Vc_IMPL=Scalar)</span></div>
<div class="line"><span class="comment">// data.size() == 2 if float_v::Size == 4 (i.e. Vc_IMPL=SSE)</span></div>
<div class="line"><span class="comment">// data.size() == 1 if float_v::Size == 8 (i.e. Vc_IMPL=AVX)</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga3ad68314ae283bc298864bf18b3aa8a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T* Vc::malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory on the Heap with alignment and padding suitable for vectorized access. </p>
<p>Memory that was allocated with this function must be released with <a class="el" href="group__Utilities.html#gaee7f695ddd66d27230262733d9727435" title="Frees memory that was allocated with Vc::malloc. ">Vc::free</a>! Other methods might work but are not portable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Specifies the number of objects the allocated memory must be able to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the allocated memory. Note, that the constructor is not called. </td></tr>
    <tr><td class="paramname">A</td><td>Determines the alignment of the memory. See <a class="el" href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">Vc::MallocAlignment</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to memory of the requested type, or 0 on error. The allocated memory is padded at the end to be a multiple of the requested alignment <code>A</code>. Thus if you request memory for 21 int objects, aligned via Vc::AlignOnCacheline, you can safely read a full cacheline until the end of the array, without generating an out-of-bounds access. For a cacheline size of 64 Bytes and an int size of 4 Bytes you would thus get an array of 128 Bytes to work with.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><ul>
<li>The standard malloc function specifies the number of Bytes to allocate whereas this function specifies the number of values, thus differing in a factor of sizeof(T). </li>
<li>This function is mainly meant for use with builtin types. If you use a custom type with a sizeof that is not a multiple of 2 the results might not be what you expect. </li>
<li>The constructor of T is not called. You can make up for this: <div class="fragment"><div class="line">SomeType *array = <span class="keyword">new</span>(Vc::malloc&lt;SomeType, Vc::AlignOnCacheline&gt;(N)) SomeType[N];</div>
</div><!-- fragment --></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#gaee7f695ddd66d27230262733d9727435" title="Frees memory that was allocated with Vc::malloc. ">Vc::free</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaee7f695ddd66d27230262733d9727435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Vc::free </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory that was allocated with <a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access. ">Vc::malloc</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pointer to the memory to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the allocated memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The destructor of T is not called. If needed, you can call the destructor before calling free: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; ++i) {</div>
<div class="line">  p[i].~T();</div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__Utilities.html#gaee7f695ddd66d27230262733d9727435">Vc::free</a>(p);</div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access. ">Vc::malloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga317df7475aed35c78a01edb20acb15c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prefetchForOneRead </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structVc_1_1Prefetch.html">Prefetch</a> the cacheline containing <code>addr</code> for a single read access. </p>
<p>This prefetch completely bypasses the cache, not evicting any other data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The cacheline containing <code>addr</code> will be prefetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga26078dd5d6dce8a1322e5f5c93cc29ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Vc::Common::prefetchForModify </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structVc_1_1Prefetch.html">Prefetch</a> the cacheline containing <code>addr</code> for modification. </p>
<p>This prefetch evicts data from the cache. So use it only for data you really will use. When the target system supports it the cacheline will be marked as modified while prefetching, saving work later on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The cacheline containing <code>addr</code> will be prefetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa73e3a7f64b8f7985a28a8d76afc611a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prefetchClose </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structVc_1_1Prefetch.html">Prefetch</a> the cacheline containing <code>addr</code> to L1 cache. </p>
<p>This prefetch evicts data from the cache. So use it only for data you really will use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The cacheline containing <code>addr</code> will be prefetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga77ab6bddef535f11852d1d6e786fb3db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prefetchMid </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structVc_1_1Prefetch.html">Prefetch</a> the cacheline containing <code>addr</code> to L2 cache. </p>
<p>This prefetch evicts data from the cache. So use it only for data you really will use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The cacheline containing <code>addr</code> will be prefetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac70f007961d35e633d360fa38970628b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prefetchFar </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structVc_1_1Prefetch.html">Prefetch</a> the cacheline containing <code>addr</code> to L3 cache. </p>
<p>This prefetch evicts data from the cache. So use it only for data you really will use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The cacheline containing <code>addr</code> will be prefetched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa18ac68167ac7614731134de7364a1d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr WhereImpl::WhereMask&lt;M&gt; Vc::where </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conditional assignment. </p>
<p>Since compares between SIMD vectors do not return a single boolean, but rather a vector of booleans (mask), one often cannot use if / else statements. Instead, one needs to state that only a subset of entries of a given SIMD vector should be modified. The <code>where</code> function can be prepended to any assignment operation to execute a masked assignment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The mask that selects the entries in the target vector that will be modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns an opaque object that binds to the left operand of an assignment via the binary-or operator or the functor operator. (i.e. either <code>where(mask) | x = y</code> or <code>where(mask)(x) = y</code>)</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> f1(T &amp;x, T &amp;y)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (x &lt; 2) {</div>
<div class="line">    x *= y;</div>
<div class="line">    y += 2;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> f2(T &amp;x, T &amp;y)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="group__Utilities.html#gaa18ac68167ac7614731134de7364a1d5">where</a>(x &lt; 2) | x *= y;</div>
<div class="line">  <a class="code" href="group__Utilities.html#gaa18ac68167ac7614731134de7364a1d5">where</a>(x &lt; 2) | y += 2;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The block following the if statement in <code>f1</code> will be executed if <code>x &lt; 2</code> evaluates to <code>true</code>. If <code>T</code> is a scalar type you normally get what you expect. But if <code>T</code> is a SIMD vector type, the comparison will use the implicit conversion from a mask to bool, meaning <code>all_of(x &lt; 2)</code>.</p>
<p>Most of the time the required operation is a masked assignment as stated in <code>f2</code>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
