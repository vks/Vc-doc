<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Vc: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Vc"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vc
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">SIMD Vector Classes for C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('intro.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>If you are new to vectorization please read this following part and make sure you understand it: </p><ul>
<li>Forget what you learned about vectors in math classes. SIMD vectors are a different concept! </li>
<li>Forget about containers that also go by the name of a vector. SIMD vectors are a different concept! </li>
<li>A vector is defined by the hardware as a special register which is wider than required for a single value. Thus multiple values fit into one register. The width of this register and the size of the scalar data type in use determine the number of entries in the vector. Therefore this number is an unchangeable property of the hardware and not a variable in the Vc API. </li>
<li>Note that hardware is free to use different vector register widths for different data types. For example AVX has instructions for 256-bit floating point registers, but only 128-bit integer instructions.</li>
</ul>
<dl class="section user"><dt>Example 1:</dt><dd></dd></dl>
<p>You can modify a function to use vector types and thus implement a horizontal vectorization. The original scalar function could look like this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> normalize(<span class="keywordtype">float</span> &amp;x, <span class="keywordtype">float</span> &amp;y, <span class="keywordtype">float</span> &amp;z)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">float</span> d = <a class="code" href="group__Math.html#ga68be745cb2c851120683a05c252bea7b">std::sqrt</a>(x * x + y * y + z * z);</div>
<div class="line">  x /= d;</div>
<div class="line">  y /= d;</div>
<div class="line">  z /= d;</div>
<div class="line">}</div>
</div><!-- fragment --><p> To vectorize the <code>normalize</code> function with Vc, the types must be substituted by their Vc counterparts and math functions must use the Vc implementation (which is, per default, also imported into <code>std</code> namespace): </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="classVc_1_1float__v.html">Vc::float_v</a>;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> normalize(float_v &amp;x, float_v &amp;y, float_v &amp;z)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> float_v d = <a class="code" href="group__Math.html#ga68be745cb2c851120683a05c252bea7b">Vc::sqrt</a>(x * x + y * y + z * z);</div>
<div class="line">  x /= d;</div>
<div class="line">  y /= d;</div>
<div class="line">  z /= d;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The latter function is able to normalize four 3D vectors when compiled for SSE in the same time the former function normalizes one 3D vector.</p>
<p>For completeness, note that you can optimize the division in the normalize function further: </p><div class="fragment"><div class="line"><span class="keyword">const</span> float_v d_inv = <a class="code" href="group__Vectors.html#gga637228b0c9f9022584b3df6248183205a90255397b7fea62517410396d914b2bd">float_v::One</a>() / <a class="code" href="group__Math.html#ga68be745cb2c851120683a05c252bea7b">Vc::sqrt</a>(x * x + y * y + z * z);</div>
<div class="line"><span class="keyword">const</span> float_v d_inv = <a class="code" href="group__Math.html#ga90a6b41bec4d26e267f030cb3bc3151e">Vc::rsqrt</a>(x * x + y * y + z * z); <span class="comment">// less accurate, but faster</span></div>
</div><!-- fragment --><p> Then you can multiply <code>x</code>, <code>y</code>, and <code>z</code> with <code>d_inv</code>, which is considerably faster than three divisions.</p>
<p>As you can probably see, the new challenge with Vc is the use of good data-structures which support horizontal vectorization. Depending on your problem at hand this may become the main focus of design (it does not have to be, though).</p>
<h1><a class="anchor" id="intro_alignment"></a>
Alignment</h1>
<h2><a class="anchor" id="intro_alignment_background"></a>
What is Alignment</h2>
<p>If you do not know what alignment is, and why it is important, read on, otherwise skip to <a class="el" href="intro.html#intro_alignment_tools">Tools</a>. Normally the alignment of data is an implementation detail left to the compiler. Until C++11, the language did not even have any (official) means to query or modify alignment.</p>
<p>Most data types require more than one Byte for storage. Thus, even most atomic data types span several locations in memory. E.g. if you have a pointer to <code>float</code>, the address stored in this pointer just determines the first of four Bytes of the <code>float</code>. Naively, one could think that any address (which belongs to the process) can be used to store such a float. While this is true for some architectures, some architectures may terminate the process when a misaligned pointer is dereferenced. The natural alignment for atomic data types typically is the same as their size. Thus the address of a <code>float</code> object should always be a multiple of 4 Bytes.</p>
<p>Alignment becomes more important for SIMD data types. 1. There are different instructions to load/store aligned and unaligned vectors. The unaligned load/stores recently were greatly improved in x86 CPUs. Still, the rule of thumb says that aligned loads/stores are faster. 2. Access to an unaligned vector with an instruction that expects an aligned vector crashes the application. Once you write vectorized code you might want to make it a habit to check crashes for unaligned addresses. 3. Memory allocation on the heap will return addresses aligned to some system specific alignment rule. E.g. Linux 32bit aligns on 8 Bytes, while Linux 64bit aligns on 16 Bytes. Both alignments are not strict enough for AVX vectors. Worse, if you develop on Linux 64bit with SSE you won't notice any problems until you switch to a 32bit build or AVX. 4. Placement on the stack is determined at compile time and requires the compiler to know the alignment restrictions of the type. 5. The size of a cache line is just two or four times larger than the SIMD types (if not equal). Thus, if you load several vectors consecutively from memory every fourth, second, or even every load will have to be read from two different cache lines. This is called a cache line split. They lead to degraded performance, which becomes very noticeable for memory intensive code.</p>
<h2><a class="anchor" id="intro_alignment_tools"></a>
Tools</h2>
<p>Vc provides several classes and functions to get alignment right. </p><ul>
<li><a class="el" href="group__Vectors.html#ggafc69e2f69e7e54557954b8da4bd6c6afa65da35888fae8203b2da4f4e92523f50" title="Specifies the byte boundary for memory alignments necessary for aligned loads and stores...">Vc::VectorAlignment</a> is a compile time constant that equals the largest alignment restriction (in Bytes) for the selected target architecture. </li>
<li><a class="el" href="structVc_1_1AlignedBase.html" title="Helper class to ensure a given alignment. ">Vc::AlignedBase</a>, <a class="el" href="group__Utilities.html#gae0b1347db1c228fa9eed28bb263b7ce1" title="Helper type to ensure suitable alignment for any Vc::Vector<T> type (using the default VectorAbi)...">Vc::VectorAlignedBase</a>, and <a class="el" href="group__Utilities.html#ga199bb5c0b1cdad984233700da70c7f72" title="Helper class to ensure suitable alignment for arrays of scalar objects for any Vc::Vector<T> type (us...">Vc::MemoryAlignedBase</a> implement the alignment restrictions needed for aligned vector loads and stores. They set the alignment attribute and reimplement the <code>new</code> and <code>delete</code> operators, returning correctly aligned pointers to the heap. </li>
<li><a class="el" href="group__Utilities.html#ga3ad68314ae283bc298864bf18b3aa8a4" title="Allocates memory on the Heap with alignment and padding suitable for vectorized access. ">Vc::malloc</a> and <a class="el" href="group__Utilities.html#gaee7f695ddd66d27230262733d9727435" title="Frees memory that was allocated with Vc::malloc. ">Vc::free</a> are meant as replacements for <code>malloc</code> and <code>free</code>. They can be used to allocate any type of memory with an abstract alignment restriction: <a class="el" href="group__Utilities.html#gaebce8b3227fdcca97fba94556a1b2461">Vc::MallocAlignment</a>. Note, that (like <code>malloc</code>) the memory is only allocated and not initialized. If you allocate memory for a type that has a constructor, use the placement new syntax to initialize the memory. </li>
<li>Vc::Allocator is an STL compatible allocator class that behaves as specified in the C++ specification, implementing the optional support for over-aligned types. Therefore, memory addresses returned from this allocator will always be aligned to at least the constraints attached to the type <code>T</code>. STL containers will already default to Vc::Allocator for Vc::Vector&lt;T&gt;. For all other composite types you want to use, you can take the Vc_DECLARE_ALLOCATOR convenience macro to set is as default. </li>
<li>Vc::Memory, Vc::Memory&lt;V, Size, 0u&gt;, Vc::Memory&lt;V, 0u, 0u&gt; The three different variants of the memory class can be used like a more convenient C-array. It supports two-dimensional statically sized arrays and one-dimensional statically and dynamically sized arrays. The memory can be accessed easily via aligned vectors, but also via unaligned vectors or gathers/scatters. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
